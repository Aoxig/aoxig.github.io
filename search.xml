<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>六大设计原则</title>
    <url>/reading-notes/six_design_principle.html</url>
    <content><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>定义：应该有且仅有一个原因引起类的变更（There should never be more than one reason for a class to change.）</p>
<a id="more"></a>
<p>好处：</p>
<ol>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高；</li>
<li>可维护性高；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性，维护性都有非常大的帮助。</li>
</ol>
<p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>
<h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>定义：所有引用基类的地方必须能够透明地使用其子类地对象（Functions that use pointers or refenrences to base classes must be able to use objects of derived classed without knowing it.）</p>
<p>通俗来说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p>
<ol>
<li><p>子类必须完全实现父类的方法</p>
<p> 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖，聚集，组合等关系代替继承。</p>
</li>
<li><p>子类可以有自己的个性</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
